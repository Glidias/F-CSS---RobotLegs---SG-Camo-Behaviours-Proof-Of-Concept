/**  * <p>Original Author:  jessefreeman</p> * <p>Class File: TypeHelper.as</p> *  * <p>Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions:</p> *  * <p>The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software.</p> *  * <p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE.</p> *  * <p>Licensed under The MIT License</p> * <p>Redistributions of files must retain the above copyright notice.</p> *	 * <p>The TypeHelper converts strings into native typed values. This *	is useful when getting property values from XML or url request *	and doing converting on the fly.</p> *  * <p>Revisions<br/>  * 	2.0  Initial version Jan 7, 2009 * 	2.1  Replaced getType switch with function lookup object May 6, 2009</p> *  */package camo.core.utils {	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.net.URLRequest;	import flash.text.StyleSheet;	import flash.utils.Dictionary;	public class TypeHelperUtil 	{		public static const STRING : String = "string";		public static const NUMBER : String = "number";		public static const BOOLEAN : String = "boolean";		public static const ARRAY : String = "array";		public static const DICTIONARY : String = "flash.utils::dictionary";		public static const OBJECT : String = "object";		public static const UINT : String = "uint";		public static const RECTANGLE : String = "flash.geom::rectangle";		public static const POINT : String = "flash.geom::point";		public static const STYLE_SHEET : String = "flash.text::stylesheet";		public static const URL_REQUEST : String = "flash.net::urlrequest";		/**		 * 		 */		private static const COLORS : Object = new Object( );		{		COLORS["black"] = 0x000000;		COLORS["blue"] = 0x0000FF;		COLORS["green"] = 0x008000;		COLORS["gray"] = 0x808080;		COLORS["silver"] = 0xC0C0C0;		COLORS["lime"] = 0x00FF00;		COLORS["olive"] = 0x808000;		COLORS["white"] = 0xFFFFFF;		COLORS["yellow"] = 0xFFFF00;		COLORS["maroon"] = 0x800000;		COLORS["navy"] = 0x000080;		COLORS["red"] = 0xFF0000;		COLORS["purple"] = 0x800080;		COLORS["teal"] = 0x008080;		COLORS["fuchsia"] = 0xFF00FF;		COLORS["aqua"] = 0x00FFFF;		COLORS["magenta"] = 0xFF00FF;		COLORS["cyan"] = 0x00FFFF;		}						// Provided support for unknown_type_handler		/**		 * 		 */		public static var unknown_type_handler:Function = null;						/**		 * 		 */		private static const FUNCTION_MAP : Object = new Object( );		{		// added required immediate "string" resolve method to prevent using unknown_type_handler if data type is already a string. 		// This method can be removed by the user with TypeHelperUtil.removeFunction(TypeHelperUtil.STRING) if the user wishes to 		// resolve a string manually in his custom unknown_type_handler as well, or replaced with TypeHelperUtil.registerFunction(....		FUNCTION_MAP[STRING] = immediateStringResolve; 		FUNCTION_MAP[NUMBER] = stringToNumber; 		FUNCTION_MAP[BOOLEAN] = stringToBoolean, 		FUNCTION_MAP[ARRAY] = stringToArray,		FUNCTION_MAP[DICTIONARY] = stringToDictionary,		FUNCTION_MAP[OBJECT] = stringToObject,		FUNCTION_MAP[UINT] = stringToUint,		FUNCTION_MAP[RECTANGLE] = stringToRectangle,		FUNCTION_MAP[POINT] = stringToPoint,		FUNCTION_MAP[STYLE_SHEET] = stringToStyleSheet,		FUNCTION_MAP[URL_REQUEST] = stringToUrlRequest;		}		/**		 * <p>This method allows you to register other functions to handle new types		 * this utility is not set up to convert to, or overwrite existing types to new functions.</p>		 */		public static function registerFunction(name : String, funct : Function) : void		{			FUNCTION_MAP[name] = funct;		}		/**		 * Manually removes a function mapping		 * @param	name		 */		public static function removeFunction(name : String) : void		{			delete FUNCTION_MAP[name];		}				public static function registerColor(name:String, color: uint):void		{			COLORS[name] = color;		}				public static function removeColor(name:String):void		{			delete COLORS[name];		}		/**		 * <p>This function handles converting the data into the supplied type.</p>		 *			 *	<p>This function also has a special default function call when		 *	unknown_type_handler is set. To use this supply a function to call		 *	when the helper class doesn't know what to convert the data to.</p>		 *			 *	<p>The unknown_type_handler should accept data and type. This allows		 *	you to customize the class and extend its functionality on the fly 		 *	without having to directly extend and override the main switch logic.</p>		 *			 *	@param data String representing the value that needs to be		 *	converted.		 *	@param type String representing the type the data should be 		 *	converted into. Accepts string, number, array, boolean, associate		 *	array, dictionary, object, color and hex color.		 *	@return Converted data typed to supplied type value.		 *			 */		public static function getType(data : String, type : String) : * 		{			return FUNCTION_MAP[type] ? FUNCTION_MAP[type]( data ) : unknown_type_handler!=null ? unknown_type_handler(data,type) : data;		}				private static function immediateStringResolve(str:String):String {			return str;		}		public static function stringToNumber(value : String) : Number		{			return Number( value );		}		/**		 * By default this method is set up to convert CSS style arrays dlimited by spaces.		 */		public static function stringToArray(value : String, delimiter : String = " ") : Array		{			return value.split( delimiter );		}		public static function splitTypeFromSource(value : String) : Object 		{			var obj : Object = new Object( );			// Pattern to strip out ',", and ) from the string;			var pattern : RegExp = RegExp( /[\'\)\"]/g );// this fixes a color highlight issue in FDT --> '			// Fine type and source			var split : Array = value.split( "(" );			//			obj.type = split[0];			obj.source = split[1].replace( pattern, "" );						return obj;		}		/**		 *		 */				 // Added optional delimiter variables - Glenn		public static function stringToDictionary(value : String, dataDelimiter : String = "," ,propDelimiter : String = ":") : Dictionary		{			return stringToComplexArray( value, DICTIONARY, dataDelimiter, propDelimiter );		}		// Added optional delimiter variables - Glenn		public static function stringToObject(value : String, dataDelimiter : String = "," ,propDelimiter : String = ":") : Object		{			return stringToComplexArray( value, OBJECT, dataDelimiter, propDelimiter );		}		/**		 * <p>This function parses out a complex array and puts it into an Associate 		 * Array, Dictionary, or Object. Use this function to split up the array base		 * on the dataDelimiter (default ",") and the propDelimiter (default ":").</p>		 *			 * <p>Example of a data: "up:play,over:playO,down:playO,off_up:pause,off_over:pauseO,off_down:pauseO"</p>		 *			 */		protected static function stringToComplexArray(data : String, returnType : String, dataDelimiter : String = "," ,propDelimiter : String = ":") : * 		{						var dataContainer : *;						// Determine what type of object to return			switch (returnType) 			{				case DICTIONARY:					dataContainer = new Dictionary( );					break;				case OBJECT:					dataContainer = new Object( );					break;			}						var list : Array = data.split( dataDelimiter );			var total : Number = list.length;			for (var i : Number = 0; i < total ; i ++) 			{				var prop : Array = list[i].split( propDelimiter );				dataContainer[prop[0]] = prop[1];			}						return dataContainer;		}		/**		 * <p>Converts a string to a boolean.</p>		 */		public static function stringToBoolean(value : String) : Boolean 		{			return (value == "true") ? true : false;		}		/**		 * <p>Converts a string into a uint. This function also supports converting		 * colors into .</p>		 */		public static function stringToUint(value : String) : uint		{			// Check to see if it is a registered color			if(COLORS[value])			{				return COLORS[value];			}			else			{				value = value.substr( - 6, 6 );				var color : uint = Number( "0x" + value );				return color;			}		}		/**		 * <p>Converts rgb to hex.</p>		 * 		 */		public static function rgbToHex(r : Number, g : Number, b : Number) : Number 		{			return r << 16 | g << 8 | b;		}		/**		 * <p>Use this to turn Yes No values into True or False.</p>		 *			 *	@param value Accepts "yes" for true or "no" for false.		 */		public static function stringYesNoToBoolean(value : String) : Boolean 		{			if(value.toLowerCase( ) == "yes") 			{				return true;				} 			else 			{				return false;				}		}		/**		 * 		 * @param value		 * @param delimiter		 * @return 		 * 		 */				public static function stringToRectangle(value : String, delimiter : String = " ") : Rectangle 		{			var coords : Array = splitTypeFromSource( value ).source.split( delimiter, 4 );						if((value == "") || (coords.length != 4)) 			{				return null;			} 			else 			{				return new Rectangle( coords[0], coords[1], coords[2], coords[3] );			}		}		/**		 * 		 * @param value		 * @param delimiter		 * @return 		 * 		 */				public static function stringToPoint(value : String, delimiter : String = " ") : Point 		{			var coords : Array = splitTypeFromSource( value ).source.split( delimiter, 2 ); 			return new Point( Number( coords[0] ), Number( coords[1] ) );		}		/**		 * 		 * @param value		 * @return 		 * 		 */				public static function stringToStyleSheet(value : String) : StyleSheet 		{						var styleSheet : StyleSheet = new StyleSheet( );			styleSheet.parseCSS( value );			return styleSheet;		}		public static function stringToUrlRequest(value : String) : URLRequest		{			return new URLRequest( splitTypeFromSource( value ).source );		}	}}