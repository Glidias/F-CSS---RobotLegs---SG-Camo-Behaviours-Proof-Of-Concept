package sg.camolite.display {
	import sg.camo.interfaces.IIndexable;
	import sg.camo.interfaces.IIterarable;
	import flash.display.DisplayObject;
	import flash.display.Sprite;
	import flash.events.Event;
	
	
	
	/**
	* Extended GSelection class to support indexable and ordered selections.
	* 
	* @author Glenn Ko
	*/
	public class GOrderedSelection extends GSelection implements IIndexable, IIterarable {
		
		/** The indexable array of selectable instances. <b>This must be generated by <code>scan</code>()</b> */
		protected var _indexArr:Array;  
		
		/** @private */
		protected static const INACTIVE:int = -2;    // lower than -1 to indiciate non-indexable selection
		/** @private */
		protected static const UNSELECTED:int = -1;  // at least -1 to denote indexable selection
		
		/** @private */
		protected var _curIndex:int = INACTIVE;
			
		public function GOrderedSelection() {
			
		}
		
		// -- IReflectClass
		
		override public function get reflectClass():Class {
			return GOrderedSelection;
		}			
		
		/**
		 * <b>Required</b> to scan a specific target location sprite which contains <i>only</i> ISelectable children
		 * in order to register them into an indexable array.
		 * <br/>
		 * <i>
		 * TODO: This could be fleshed out to be more flexible, user-friendly and less prescriptive.
		 * <br/>Automatically scan one's own display list??
		 * </i>
		 * @param	targ	(Sprite)
		 */
		override public function scan(targ:Sprite):void {
			_indexArr = new Array(targ.numChildren);
			super.scan(targ);
		}
		
		/**
		 * Returns currently selected index by default.
		 * @return	The currently selected index
		 */
		public function getIndex():int {
			return _curIndex;
		}
		
		/**
		 * Attempts to perform selection by index
		 * @param	id	(int) 
		 */
		public function setIndex(id:int):void {
			if (_curIndex == INACTIVE) {
				trace("GSelection setIndex():: No indexing enabled.");  return;
			}
			if (id < 0 || id > _indexArr.length-1) {
				trace("GSelection setIndex():: Out of bounds. - " + id); return;
			}
			doSelection(_indexArr[id]);
		}
		
		/**
		 * @private
		 * Extended processSelectableChild() method to check for indexing of children,
		 * and indexes them accordingly. (might need a bit of reworking to improve flexibily)
		 * @param	child
		 */
		override protected function processSelectableChild(child:DisplayObject):void {
			super.processSelectableChild(child);
			var indexable:IIndexable = child as IIndexable;
			var cIndex:int = 1;
			
			if (indexable != null) {
				var chkIndex:int = indexable.getIndex();
				cIndex = chkIndex > -1 ? chkIndex : getSelectableIndexOf(child, chkIndex);
				(child as IIndexable).setIndex(cIndex);
				_curIndex = UNSELECTED;  
			}
			_indexArr[cIndex] = child;
		}
		
		/**
		 * @private
		 * @param	child
		 * @param	chkIndex
		 * @return
		 */
		protected function getSelectableIndexOf(child:DisplayObject, chkIndex:int):int {
			var autoSetIndex:int = child.parent != null ? child.parent.getChildIndex(child) : chkIndex;
			return autoSetIndex;
		}

		
		
		override public function destroy():void {
			super.destroy();
			_indexArr = null;
		}
		

		
		/**
		 * @private
		 * @param	e
		 */
		protected function nextSelectionHandler(e:Event):void {
			nextSelection();
		}
		/**
		 * @private
		 * @param	e
		 */
		protected function prevSelectionHandler(e:Event):void {
			prevSelection();
		}
		
		/**
		 * Goes to next selection
		 */
		public function goNext():void {
			nextSelection();
		}
				
		/**
		 * Goes to prev selection
		 */
		public function goPrev():void {
			prevSelection();
		}
		
		/** @private */
		protected function nextSelection():void {
			if (_curIndex ==INACTIVE || _curIndex > _indexArr.length - 2) return;
			doSelection(_indexArr[_curIndex+1]);
		}
		/** @private */
		protected function prevSelection():void {
			if (_curIndex ==INACTIVE) return;
			doSelection(_indexArr[_curIndex-1]);
		}
		
		override public function  doSelection(targ:*):Boolean {
			var success:Boolean = super.doSelection(targ);
			if (!success || _curIndex == INACTIVE) return false;
			if (targ is IIndexable) _curIndex = (targ as IIndexable).getIndex(); 
			return success;
		}
		

		
		override public function clearSelection():void {
			super.clearSelection();
			if (_curIndex == INACTIVE) return;
			_curIndex = -1;
		}
		
	}
	
}